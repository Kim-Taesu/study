#### 스트림처리

- 신규 데이터를 끊임없이 처리해 결과를 만들어내는 행위
- 스트림 처리의 입력 데이터는 무한하며 시작과 끝을 사전에 정의하지 않는다.
- 입력 데이터 스트림 처리 시스템에 도착한 일련의 이벤트

#### 배치 처리 + 스트림 처리

- 배치 처리 
  - 고정된 입력데이터를 사용
  - 결과를 한 번만 만들어낸다.
  - 직관적이며 유지 보수와 개발이 비교적 단순
  - 스트리밍 시스템보다 훨씬 높은 처리량을 얻을 수 있다.
- 스트리밍 작업의 출력이 배치 작업용 쿼리에 필요한 파일이나 테이블인 경우도 있다.
- 모든 비즈니스 로직은 스트리밍과 배치 연산에서 일관성 있게 동작해야 한다.

#### 구조적 스트리밍

- 배치 애플리케이션뿐만 아니라 나머지 컴포넌트와 쉽게 연동할 수 있도록 설계
- 레코드 단위 스트림 처리를 넘어 연속형 애플리케이션을 쉽게 구현하기 위해 설계

#### 연속형 애플리케이션

- 스트리밍, 배치 그리고 대화형 작업으로 구성된 통합 애플리케이션

#### 스트림 처리 사례

- 통보와 알림
- 실시간 리포트
- 중분형 ETL
- 실시간 제공용 데이터 갱신
- 실시간 의사 결정

---

#### 스트림 처리의 장점

- 대기 시간이 짧다.
- 자동으로 연산 결과의 증분을 생성하므로 반복적인 배치 작업보다 결과를 수정하는 데 더 효율적이다.

#### 스트림 처리의 문제점

- 애플리케이션 타임스탬프 기준으로 순서가 뒤섞인 데이터 처리
- 대규모의 상태 정보 유지하기
- 높은 데이터 처리량 보장
- 장애 상황에서도 정확히 한 번 처리
- 부하 불균형과 뒤처진 서버 다루기
- 이벤트에 빠르게 응답하기
- 다른 저장소 시스템의 외부 데이터와 조인
- 출력 시스템에 데이터 저장 시 트랜잭션 보장
- 런타임에 비즈니스 로직 변경

---

#### 스트리밍 API

- 스트리밍 API를 설계하는 가장 간단한 방법은 각 이벤트를 애플리케이션에 전달하고 사용자 코드에 반응하도록 만드는 것
  - 애플리케이션이 데이터 처리와 관련된 완벽한 제어권을 가져야 하는 분야에서 중요한 위치를 차지

#### 레코드 단위 처리 API

- 애플리케이션 내부에서 여러 처리 파이프라인을 연결하는 기능만 제공
- 사용자가 직접 상태를 추적해야한다.
- 메모리 확보를 위한 상태 제거와 중복 처리 방지 등의 기능을 직접 구현해야 한다.

#### 선언형 API

- 애플리케이션을 정의할 때 '어떻게' 신규 데이터를 처리하고 장애 상황에서 복구할지 지정하는 대신 '무엇'을 처리할지 지정
- 스파크의 DStream API는 `맵, 리듀스, 필터`같은 연산을 기반으로 하는 함수형 API를 제공
  - DStream API는 내부적으로 각 연산자의 데이터 처리량과 연산 관련 상태 정보를 자동으로 추적하고 관련 상태를 신뢰도 있게 저장

---

#### 이벤트 시간과 처리 시간

- 이벤트 시간 처리
  - 원천 시스템에서 각 레코드에 기록한 타임스탬프를 기반으로 데이터를 처리하는 방식
- 처리 시간 기준 처리
  - 스트리밍 애플리케이션에 레코드가 도착한 시간을 기반으로 처리하는 방식
- 스트리밍 레코드는 순서가 뒤 섞일 수 있다.
- 문제점 고려 사항
  - 시스템은 늦게 도착한 이벤트를 처리할 수 있도록 상태를 추적해야 한다.
  - 이벤트 시간이 속한 특정 시간 윈도우의 결과를 가장 적절하게 출력할 수 있는 시점을 결정해야 한다.

---

#### 연속형 처리

- 각 노드는 다른 노드에서 전송하는 메시지를 끊임없이 수신하고 새로 갱신된 정보를 자신의 하위 노드로 전송
  - `map 연산`을 구현한 각 노드는 입력 소스에서 레코드를 하나씩 읽고 함수를 적용한 후 적합한 `리듀서`로 전
- 한 번에 한 레코드만 처리
- 각 노드가 신규 메시지에 즉시 반응하기 때문에 전체 입력량이 비교적 적을 때 가장 빠르게 응답
- 단점
  - 레코드 단위 부하가 매우 크기 때문에 최대 처리량이 적다.
  - 연속형 처리 시스템은 다음 처리 노드로 메시지 패킷을 보내기 위해 OS를 호출하는 연산 부하가 발생
  - 고정형 연산 토폴로지를 사용하므로 전체 시스템을 중지해야 애플리케이션을 변경할 수 있다.

#### 마이크로 배치 시스템

- 입력 데이터를 작은 배치로 모으기 위해 대기
- 배치 잡 실행 방식과 유사하게 다수의 분산 태스크를 이용해 각 배치를 병렬로 처리
  - 배치 시스템의 최적화 기법을 사용할 수 있다. (ex : 백터화 처리 최적화 기법)
- 더 높은 노드당 처리량을 얻을 수 있다.
- 레코드별 부하가 없다.
- 더 적은 노드로 같은 양의 데이터를 처리할 수 있다.
- 워크로드 변화에 대응할 수 있도록 태스크 수를 늘리거나 줄이는 방식인 부하 분산 기술을 동적으로 사용할 수 있다.
- 단점
  - 배치를 모으기 위한 시간이 필요하므로 기본적인 지연 시간이 발생

#### 두 처리 방식 선택

- 지연 시간 요건과 총 운영비용을 고려해야 한다.
- 마이크로 배치 시스템
  - 애플리케이션에 따라 100ms부터 초 단위의 응답시간을 안정적으로 제공
  - 일반적으로 더 적은 노드 수로 동일한 처리량을 얻을 수 있으므로 운영비용을 낮출 수 있다.
  - 노드 장애가 덜 발생하기 때문에 운영비용이 낮다.

---

#### 스파크의 스트리밍 API

- DStream API
  - 마이크로 배치 방식으로만 동작
  - 선언형 API를 가지고 있지만 이벤트 시간 처리를 지원하지 않는다.
- 구조적 스트리밍 aPI
  - 최적화 기술, 이벤트 시간 그리고 연속형 처리를 지원

#### DStream API

- 스파크 스트리밍은 기본적으로 RDD 코드를 함께 사용해 정적 데이터와 조인하는 등의 기능을 지원
- 제약 사항
  - 많은 장점을 제공하는 구조적 테이블 개념의 DataFrame이나 Dataset과 달리 자바나 파이썬의 객체와 함수에 매우 의존적이다.
    - 스트림 처리 엔진이 제공하는 최적화 기법을 적용 못한다.
  - DStream API는 기본적으로 처리 시간을 기준으로 동작
    - 이벤트 시간 기준으로 처리하고 싶은 경우에는 자체적으로 구현해야 한다.
  - DStream API는 마이크로 배치 형태로만 동작
    - 다른 처리 모드를 지원할 수 없다.

#### 구조적 스트리밍

- 스파크의 구조적 API를 기반으로 하는 고수준 스트리밍 API
- 다양한 언어를 사용해 구조적 처리를 할 수 있는 모든 환경에서 사용할 수 있다.
- 이벤트 시간 데이터 처리를 지원
- 단순한 스트림 처리를 넘어 스트리밍, 배치 그리고 대화형 쿼리를 하나로 통합한 연속형 애플리케이션을 쉽게 만들 수 있도록 설계
- 구조적 스트리밍은 데이터가 도착할 때마다 자동으로 증분 형태의 연산 결과를 만들어 낸다.
  - 개발자는 서로 다른 처리 시스템에 대한 배치와 스트리밍용 코드를 별도로 관리할 필요가 없다.
- DStream API에 사용성과 성능을 더해 진화시킨 버전