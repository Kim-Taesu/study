#### Why scala

- JVM과 자바 스크립트 언어
  - JVM의 성능과 최적화를 활용
  - 자바를 중심으로 구축된 풍부한 기존 도구와 라이브러리 생태계 사용 가능
- 정적 타입
  - 타입 추론을 사용해서 불필요한 타입 표기를 생략
- 객체지향 프로그래밍 (OOP)
  - 혼합 합성을 사용해서 타입을 깔끔하게 구현하는 Trait로 자바 객체 모델을 보완
  - 스칼라에서는 모든 것이 객체이다.
- 함수형 프로그래밍 (FP)
  - 불변값, 1급 함수, 부수 효과가 없는 함수, 고차 함수, 함수 컬렉션 등 지원



#### val 키워드

- 불변 변수를 선언



#### 타입표기

- 대상 변수 이름 뒤에 ':'을 붙인 다음에 타입 표기를 추가



#### 클래스

- 스칼라에서 클래스는 class 키워드로 시작

- 전체 클래스 본문은 중괄호 사이에 위치

- 클래스의 본문이 그 클래스의 주 생성자

- 주 생성자의 인자를 클래스 이름과 클래스 본문 사이에 나열해야 한다.

  ```scala
  case class Point(x: Double = 0.0, y: Double = 0.0)
  ```

- 클래스 선언 앞에 case를 넣으면 각각의 생성자 매개변수가 자동으로 Point 인스턴스의 읽기 전용 필드로 바뀐다.

  - 위 예제의 Point.x와 Point.y로 필드를 읽을 수 있지만 그 값을 바꿀 수는 없다.
  - 바꾸는 시도를 하면 컴파일 오류 발생
  - 컴파일러가 모든 케이스 클래스에 대해 각 클래스와 이름이 같은 싱글턴 객체인 동반 객체를 자동으로 만들어낸다.

- 



#### 메서드

```scala
def upper(strings: String*): Seq[String] = {...}
```

- 메서드 정의는 def 키워드로 시작하며, 그 다음에 메서드 이름이 온다.
- 메서드 이름 다음에는 선택적으로 매개변수 목록이 온다.
  - 그 뒤에 선택적으로 반환 타입이 올 수 있다.
  - 반환 타입은 콜론 뒤에 타입을 붙여서 표시한다.
- 마지막으로 등호(=)가 메서드 시그니처와 본문 사이에 온다.
- 괄호로 둘러싸인 매개변수 목록은 실제로는 String 으로 이루어진 가변 길이 매개변수 목록이다.
  - String 뒤에 *를 붙여 가변 길이 인자 목록을 의미함
  - 원하는 만큼 문자열을 콤마로 분리해서 인자로 넘길 수 있다. (빈 목록도 가능)
- 메서드의 반환 타입이 매개변수 목록 다음에 온다.
  - 위 예제에서는 반환 타입이 Seq[String] 이다. 
    - Seq : 일정한 순서로 반복 가능한 추상적 컬렉션
  - 각괄호([])로 Seq의 배개변수화한 타입을 지정
    - 꺽쇠괄호(<>)는 식별자에 사용 : 변수 이름이나 메서드 이름에 꺾쇠괄호 사용 가능

- upper 메서드의 본문은 등호(=) 다음에 온다.
  - 등호는 모호성을 줄이기 위해 사용
  - 등호를 사용하여 메서드가 매개변수를 받지 않는 경우 매개변수 목록을 생략할 수 있다.
  - 함수형 프로그래밍의 원칙을 강조하기 위함

#### 메서드 vs 함수

- 메서드 : 클래스나 객체 안에서 정의된 함수

- 함수 : 메서드가 아닌 경우

  - 함수를 메서드까지 포함한 일반적인 용어로 사용하는 경우도 있다.

  - 문맥에 따라 구별

  - 밑의 식은 메서드가 아닌 함수의 예이다.

    ```scala
    (s:String) => s.toUpperCase()
    ```

#### 싱글턴

- object로 선언하면 싱글턴 객체이다.
- 스칼라는 싱글턴 디자인 패턴을 언어의 1급 요소로 받아들였다.
- 스칼라 실행 환경은 object 객체를 하나만 생성한다.
  - new {객체} 불가능
- 다른 언어에서 '클래스 수준'의 멤버를 활용해야 하는 경우 스칼라에서는 object를 사용한다.
- 단점
  - 모든 계산을 단일 인스턴스로 사용해서 수행하는 것은 스레드 안전성이나 성능 문제의 우려를 낳는다.
    - 아무런 상태가 없고 객체와 외부의 상호 작용이 없으면 싱글턴 객체는 타당하다.

#### 타입 추론

- 스칼라의 타입 추론 알고리즘은 지역 타입 추론이다.
  - 일정 영역 내에서 지역적으로 작동
- 재귀 함수는 반환 타입을 반드시 지정해야 한다.

#### 위치지정자 (_)

- _는 익명 변수처럼 작동

---

#### 동시성 맛보기

- 동시성 액터 모델에는 서로 아무런 상태 정보를 공유하지 않는 액터라는 독립적인 소프트웨어 요소가 존재
- 상태를 공유하지 않는 대신 액터들은 메시지 교환을 통해 서로 의사소통한다.
- 공유한 변경 가능 상태에 대해 동기화해야할 필요성을 없앨 수 있다.
- 각 액터는 필요에 따라 자신의 상태를 바꿀 수 있다.
  - 각 액터가 배타적으로 자신의 상태에 대해서만 접근할 수 있다.
  - 액터 프레임워크가 각 액터의 코드를 스레드로 안전하게 실행

#### apply 메소드

- 동반 객체에 자동으로 추가되는 메서드

- 동반 클래스의 생성자와 같은 인자를 받는다.

- 다음 두 줄은 동등한 식이다.

- 객체를 만드는 팩토리 역할

  - new 키워드 없이 생성자를 호출

  ```scala
  val p1 = Point.apply(1.0, 2.0)
  val p2 = Point(1.0, 2.0)
  ```

#### 메서드에 전달한 인자가 함수일 때

- ```scala
  def draw(f: String => Unit): Unit = f(s"draw : ${this.toString}")
  ```

- 인자는 String => Unit 타입의 함수이다.

- f는 String을 인자로 받아 Unit을 반환

  - Unit을 반환하는 경우 오직 부수 효과만을 위한 것
  - 전역적으로 I/O를 수행, 지역적으로 어떤 객체를 변경하는 것

- 일반적으로 함수형 프로그래밍에서는 부수 효과가 없고 작업 결과를 반환값으로 돌려주는 순수 함수를 선호

  - 추론, 테스트, 재활용이 용이

#### 고차함수

- 어떤 함수가 다른 함수를 값으로 반환하거나 인자로 받는 경우

#### 세미콜론

- 예제를 구분하는 구분자
- 스칼라는 한 줄의 끝에서 식을 다음 줄로 계속 이어가야 한다고 추론하지 않는 경우, 줄 끝을 식의 끝으로 취급한다.

#### 변수 정의

- 변경 불가능한 변수를 val : 값 객체

  - val은 선언 시 반드시 초기화해야 한다.

- 변경 가능한 변수 var

  - 반드시 선언할 때 초기화 해야한다.

- 타입의 생성자 매개변수에 val이나 var를 사용할 수 있다.

  - 매개변수가 그 타입의 필드가 된다.

  - val를 사용하면 변경 불가능, var를 사용하면 변경 가능 필드

    ```scala
    class Person(val name: String, var age: Int)
    val p = new Person("kts",25)
    p.age=26
    ```

#### 범위

- 끝 값을 포함시키거나 포함시키지 않고 만들 수 있다. (증분 지정 가능)

  ```scala
  // (1~10)
  1 to 10
  // (1~9)
  1 until 10
  // (1,4,7,10)
  1 to 10 by 3
  // (10,7,4,1)
  10 to 1 by -3
  // (1,4,7,10)
  1L to 10L by 3
  ```

#### 부분함수 (PartialFunction)

- 함수가 모든 가능한 입력에 대해 결과를 정의하지는 않는다는 뜻

- 부분함수 안에는 케이스 절만 들어갈 수 있고 반드시 전체를 중괄호로 묶어야 한다.

- 케이스 절의 하나와 일치하지 않는 값이 부분 함수의 인자로 들어오면 MatchError 실행 시점 예외가 발생

  - isDefinedAt 메서드를 호출해 예외 발생 방지

  ```scala
  val pf1: PartialFunction(Any,String) = { case s:String => "Yes"}
  val pf2: PartialFunction(Any,String) = { case s:Double => "Yes"}
  ```

#### 메서드 선언

- 스칼라는 본문 앞에 등호가 있는 메서드를 함수 정의로 간주하며, 함수형 프로그래밍에서 언제나 값을 반환한다.
  - 등호를 사용하지 않으면 Unit을 반환
- copy 메서드는 기존 인스턴스를 복사하면서 일부 필드를 변경하여 새로운 객체를 만든다.
- case class가 큰 경우 매우 유용하다.

```scala
case class Point(x: Double = 0.0, y: Double = 0.0) {
  def shift(delx: Double, dely: Double) = copy(x + delx, y + dely)
}
```

#### 타입 명시

- 변경 가능한 var나 변경 불가능한 val 선언에서 값을 대입하지 않는 경우
  - 클래스 안에서 추상값을 선언하는 경우
- 모든 메서드 매개변수

#### 함수 리터럴

- 밑의 두 식은 같은 식이다.

```scala
val f1: (Int, String) => String =(i, s) => s+i
val f2: Function2[Int,String,String]=(i, s) => s+i
```

#### 튜플 리터럴

- 튜플 인스턴스는 변경 불가능한 1급 계층 값이다.

- 선언 (밑 두 식은 같다.)

  ```scala
  val t1: (Int, String) = (1,"two")
  val t2: Tuple2[Int,String] = (1,"two")
  ```

- t._n 으로 튜플에서 n번째 원소를 가져온다.

#### Option

- null 대신 사용할 것을 추천
- 추상 클래스이며, 구체적으로 서브클래스로는 값이 있는 상황을 표현하는 Some과 값이 없는 상황을 표현하는 None이 있다.
- getOrElse() 메소드
  - Som의 인스턴스인 경우 그 안에 있는 값을 반환
  - None의 인스턴스인 경우 getOrElse에 넘긴 인자를 반환
  - 예외 발생 가능성을 낮춘다.